gold.price <- rbind.xts(goldprice_old, goldprice_mid, goldprice_new)
)
system.time(
gold.price <- gold.price[!duplicated(index(gold.price)),]
)
system.time(
gold.returns <<- dailyReturn(gold.price)
)
system.time(
goldprice_old <- getMetals('gold',
from = as.Date('2005-01-01'),
to = as.Date('2009-12-31'),
auto.assign = FALSE))
system.time(
goldprice_mid <- getMetals('gold',
from = as.Date('2010-01-01'),
to = as.Date('2014-12-31'),
auto.assign = FALSE))
system.time(
goldprice_new <- getMetals('gold',
from = Sys.Date() - 365*2.1,
auto.assign = FALSE))
system.time(
gold.price <- rbind.xts(goldprice_old, goldprice_mid, goldprice_new)
)
system.time(
gold.price <- gold.price[!duplicated(index(gold.price)),]
)
system.time(
gold.returns <<- dailyReturn(gold.price)
)
system.time(
goldprice_old <- getMetals('gold',
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE))
system.time(
goldprice_mid <- getMetals('gold',
from = as.Date('2009-01-01'),
to = as.Date('2013-12-31'),
auto.assign = FALSE))
system.time(
goldprice_new <- getMetals('gold',
from = as.Date('2014-01-01'),
auto.assign = FALSE))
system.time(
gold.price <- rbind.xts(goldprice_old, goldprice_mid, goldprice_new)
)
system.time(
gold.price <- gold.price[!duplicated(index(gold.price)),]
)
system.time(
gold.returns <<- dailyReturn(gold.price)
)
system.time(
goldprice_old <- getMetals('gold',
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE))
system.time(
goldprice_mid <- getMetals('gold',
from = as.Date('2009-01-01'),
to = as.Date('2012-12-31'),
auto.assign = FALSE))
system.time(
goldprice_new <- getMetals('gold',
from = as.Date('2013-01-01'),
auto.assign = FALSE))
system.time(
gold.price <- rbind.xts(goldprice_old, goldprice_mid, goldprice_new)
)
system.time(
gold.price <- gold.price[!duplicated(index(gold.price)),]
)
system.time(
gold.returns <<- dailyReturn(gold.price)
)
write.zoo(gold.price, './refData/gold_prices.xts')
write.zoo(gold.returns, './refData/gold_returns.xts')
rm(gold.returns)
system.time(read.zoo('./refData/gold_returns.xts'))
system.time(loadtest <- read.zoo('./refData/gold_returns.xts', header = TRUE, sep = " ", FUN = toDate))
system.time(loadtest <- read.zoo('./refData/gold_returns.xts', header = TRUE, sep = " "))
head(loadtest)
class(loadtest)
system.time(loadtest <- xts(read.zoo('./refData/gold_returns.xts', header = TRUE, sep = " ")))
class(loadtest)
head(loadtest)
getHistoricalBenchData <- function(code, filePrefix) {
prices_old <- getMetals(code,
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE)
prices_mid <- getMetals('sp500',
from = as.Date('2009-01-01'),
to = as.Date('2012-12-31'),
auto.assign = FALSE)
prices_new <- getMetals('sp500',
from = as.Date('2013-01-01'),
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_mid, prices_new)
prices <- sp500.price[!duplicated(index(prices)),]
returns <<- dailyReturn(prices)
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
}
getHistoricalBenchData('gold', 'gold')
code='gold'
prices_old <- getMetals(code,
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE)
filePrefix <- code
paste0('./refData/', filePrefix, '_prices.xts')
getHistoricalBenchData <- function(code, filePrefix) {
prices_old <- getMetals(code,
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE)
prices_mid <- getMetals(code,
from = as.Date('2009-01-01'),
to = as.Date('2012-12-31'),
auto.assign = FALSE)
prices_new <- getMetals(code,
from = as.Date('2013-01-01'),
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_mid, prices_new)
prices <- prices[!duplicated(index(prices)),]
returns <<- dailyReturn(prices)
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
}
getHistoricalBenchData('gold', 'gold')
getHistoricalBenchData <- function(code, filePrefix) {
prices_old <- getMetals(code,
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
auto.assign = FALSE)
prices_mid <- getMetals(code,
from = as.Date('2009-01-01'),
to = as.Date('2012-12-31'),
auto.assign = FALSE)
prices_new <- getMetals(code,
from = as.Date('2013-01-01'),
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_mid, prices_new)
prices <- prices[!duplicated(index(prices)),]
returns <- dailyReturn(prices)
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
}
getHistoricalBenchData('gold', 'gold')
getHistoricalBenchData <- function(code, filePrefix, dataSrc) {
prices_old <- getSymbols(code,
from = as.Date('2005-01-01'),
to = as.Date('2008-12-31'),
src = dataSrc,
auto.assign = FALSE)
prices_mid <- getSymbols(code,
from = as.Date('2009-01-01'),
to = as.Date('2012-12-31'),
src = dataSrc,
auto.assign = FALSE)
prices_new <- getSymbols(code,
from = as.Date('2013-01-01'),
src = dataSrc,
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_mid, prices_new)
prices <- prices[!duplicated(index(prices)),]
returns <- dailyReturn(prices)
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
}
getHistoricalBenchData('EUR/USD', 'EURUSD', 'oanda')
getHistoricalBenchData('SPY', 'SnP500' 'yahoo')
getHistoricalBenchData('SPY', 'SnP500', 'yahoo')
?dailyReturn
QQQQ <- getSymbols('QQQQ',src='yahoo')
MSFT <- getSymbols('MSFT',src='yahoo')
head(MSFT)
MSFT <- getSymbols('MSFT',src='yahoo', auto.assign = FALSE)
head(MSFT)
head(dailyReturn(MSFT))
(29.81-29.86)/29.86
(24.2446-24.28526)/24.28526
head(dailyReturn(MSFT[,4]))
head(dailyReturn(MSFT[,3]))
gold.returns
is.null(gold.returns)
getHistoricalBenchData <- function(code, filePrefix, dataSrc,
from.date, to.date, prices_old) {
prices_new <- getSymbols(code,
from = from.date,
to = to.date,
src = dataSrc,
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_new)
prices <- prices[!duplicated(index(prices)),]
returns <- dailyReturn(prices) # Automatically uses close prices in OHLC data.
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
return(returns)
}
updateHistoricalBenchData <- function(code, filePrefix, dataSrc,
from.date, to.date, prices_old) {
prices_new <- getSymbols(code,
from = from.date,
to = to.date,
src = dataSrc,
auto.assign = FALSE)
prices <- rbind.xts(prices_old, prices_new)
prices <- prices[!duplicated(index(prices)),]
returns <- dailyReturn(prices) # Automatically uses close prices in OHLC data.
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
return(returns)
}
rm(getHistoricalBenchData())
rm(getHistoricalBenchData
)
xts()
rbind.xts(xts(), padded.xts)
head(xts())
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
getFX('gold')
getMetals('gold')
runApp()
runApp()
runApp()
runApp()
chart.RollingCorrelation(merged.returns[,1],merged.returns[,2], width = 90)
head(merged.returns)
c(paste0('Benchmark: ', input$benchmark[1]), 'Strategy')
chart.RollingCorrelation(merged.returns[,1],merged.returns[,2], width = 365)
runApp()
table.AnnualizedReturns(R = stratReturns.xts, Rf = 0.5/365)
table.AnnualizedReturns(R = stratReturns.xts, Rf = 0.05/365)
chart.RollingCorrelation(merged.returns[,1],merged.returns[,2], width = 180)
ActiveReturn(merged.returns[,1], merged.returns[,2])
ActiveReturn(merged.returns[,1], merged.returns[,2], scale=252)
ActiveReturn(merged.returns[,1], merged.returns[,2])
head(merged.returns)
ActiveReturn(merged.returns[,2], merged.returns[,1])
InformationRatio(merged.returns[,2], merged.returns[,1])
SharpeRatio.annualized(merged.returns[,2], Rf = 0.01/252)
TrackingError(merged.returns[,2], merged.returns[,1])
actRet <- ActiveReturn(merged.returns[,2], merged.returns[,1])
infoRat <- InformationRatio(merged.returns[,2], merged.returns[,1])
sharpe <- SharpeRatio.annualized(merged.returns[,2], Rf = 0.01/252)
trkErr <- TrackingError(merged.returns[,2], merged.returns[,1])
table(c(actRet, iinfoRat, sharpe, trkErr))
table(list(actRet, iinfoRat, sharpe, trkErr))
table(c(actRet, infoRat, sharpe, trkErr))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
rm(list=ls())
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
getData <- function(filePath, fileFormat){
# Prepare for importing the date and return data from the csv.
setClass('tradeDate')
setClass('dayReturn')
if (fileFormat$dFmt == 'YMD') {
setAs('character', 'tradeDate', function(from) ymd(from))
} else if (fileFormat$dFmt == 'MDY') {
setAs('character', 'tradeDate', function(from) mdy(from))
} else if (fileFormat$dFmt == 'DMY') {
setAs('character', 'tradeDate', function(from) dmy(from))
}
# Remove the % symbol, if it's there.
setAs('character', 'dayReturn',
function(from) as.numeric(sub("%", "", from)))
returnsData <- read.table(file = filePath,
sep = as.character(fileFormat$sep),
colClasses = c('tradeDate', 'dayReturn'),
header = fileFormat$head)
return(returnsData)
}
updateHistoricalBenchData <- function(code, filePrefix, dataSrc,
from.date, to.date) {
# Get the current price data and date range
prices_current <- xts(read.zoo(
paste0('./refData/', filePrefix, '_prices.xts'),
header = TRUE,
sep = ' '))
current.start.date <- min(index(prices_current))
current.end.date <- max(index(prices_current))
# Get older prices than we have now.
prices_older <- prices_current[current.start.date]
if (from.date < current.start.date) {
prices_older <- getSymbols(code,
from = from.date,
to = current.start.date - 1,
src = dataSrc,
auto.assign = FALSE)
}
# Get newer prices than we have now.
prices_newer <- prices_current[current.end.date]
if (to.date > current.end.date) {
prices_newer <- getSymbols(code,
from = current.end.date + 1,
to = to.date,
src = dataSrc,
auto.assign = FALSE)
}
prices <- rbind.xts(prices_older, prices_current, prices_newer)
prices <- prices[!duplicated(index(prices)),]
returns <- dailyReturn(prices)
# Automatically uses close prices in OHLC data.
# Overwrite the existing files with new ones.
write.zoo(prices, paste0('./refData/', filePrefix, '_prices.xts'))
write.zoo(returns, paste0('./refData/', filePrefix, '_returns.xts'))
return(returns)
}
padCalendarDays <- function(xtsData) {
# Put zero returns (i.e. PnL multiplying factor of 1) on non-traded
# dates so we can see what the worst return was for all actual n-day
# periods, not just n traded days.
dates <- as.Date(index(xtsData))
# xts objects have date as their index.
allDays.dates <- seq.Date(from = min(dates),
to = max(dates),
by = 1)
allDays.ret <- matrix(data = rep(0, dim(xtsData)[2] *
(difftime(max(dates), min(dates),
units = 'days') + 1)),
ncol = dim(xtsData)[2])
allDays.ret[match(dates, allDays.dates),] <- xtsData
allDays.ret <- xts(allDays.ret, order.by = allDays.dates)
return(allDays.ret)
}
getRollingReturns <- function(rtnsData) {
# Get rolling returns for 30, 90, 180, and 365 day periods
y_allDays <- padCalendarDays(rtnsData) + 1
# +1 to get multipliers instead of returns for use with prod.
# Work out the cumulative return for every rolling window of the sizes
# hard coded below.
rtns.30  <- rollapplyr(y_allDays, 30, prod, fill = NULL) - 1
rtns.90  <- rollapplyr(y_allDays, 90, prod, fill = NULL) - 1
rtns.180 <- rollapplyr(y_allDays, 180, prod, fill = NULL) - 1
rtns.365 <- rollapplyr(y_allDays, 365, prod, fill = NULL) - 1
return(list(rtns.30, rtns.90, rtns.180, rtns.365))
}
dt <- getData(filePath = "refData/mocRtnFile.csv",
fileFormat = data.frame(head = TRUE,
sep = ',',
dFmt = 'DMY'))
runApp()
Sys.Date() - 366
class(Sys.Date() - 366)
input <- data.frame(dates = c(Sys.Date() - 366, Sys.Date() - 1))
head(dt)
tail(dt)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
length(index(merged.returns[merged.returns[,2]>merged.returns[,1]]))
stratStartPos <- min(which(dt$date >= format(isolate(input$dates[1]))))
stratEndPos <- max(which(dt$date <= format(isolate(input$dates[2]))))
if (stratStartPos >= stratEndPos) {
updateDateRangeInput(session, inputId = 'dates',
label = h3('Date range'),
start = Sys.Date() - (5 * 365),
end = Sys.Date() - 1,
min = '2001-01-01',
max = Sys.Date() - 1)
stop("EndingDate must be > StartingDate")
}
start.Date <<- format(as.Date(dt$date[stratStartPos]), '%Y-%m-%d')
end.Date   <<- format(as.Date(dt$date[stratEndPos]), '%Y-%m-%d')
x <- dt$date[stratStartPos:stratEndPos]
y <- dt$rtn[stratStartPos:stratEndPos]
# Convert to decimal return values instead of percentage
# values for use with PerformanceAnalytics.
stratReturnsDF <- data.frame(decimalReturn = y/100, row.names = x)
stratReturns.xts <- xts(stratReturnsDF$decimalReturn,
order.by = as.Date(rownames(stratReturnsDF)))
dt <- getData(filePath = "refData/mocRtnFile.csv",
fileFormat = data.frame(head = TRUE,
sep = ',',
dFmt = 'MDY'))
stratStartPos <- min(which(dt$date >= format(isolate(input$dates[1]))))
stratEndPos <- max(which(dt$date <= format(isolate(input$dates[2]))))
if (stratStartPos >= stratEndPos) {
updateDateRangeInput(session, inputId = 'dates',
label = h3('Date range'),
start = Sys.Date() - (5 * 365),
end = Sys.Date() - 1,
min = '2001-01-01',
max = Sys.Date() - 1)
stop("EndingDate must be > StartingDate")
}
start.Date <<- format(as.Date(dt$date[stratStartPos]), '%Y-%m-%d')
end.Date   <<- format(as.Date(dt$date[stratEndPos]), '%Y-%m-%d')
x <- dt$date[stratStartPos:stratEndPos]
y <- dt$rtn[stratStartPos:stratEndPos]
# Convert to decimal return values instead of percentage
# values for use with PerformanceAnalytics.
stratReturnsDF <- data.frame(decimalReturn = y/100, row.names = x)
stratReturns.xts <- xts(stratReturnsDF$decimalReturn,
order.by = as.Date(rownames(stratReturnsDF)))
stratStartPos
isolate(input$dates[1])
dt$date
class(dt$date)
class(format(isolate(input$dates[1])))
stratStartPos <- min(which(dt$date >= as.Date(isolate(input$dates[1]))))
isolate(input$dates[1])
stratStartPos <- min(which(dt$date >= ymd(isolate(input$dates[1]))))
stratStartPos <- min(which(dt$date >= isolate(ymd(input$dates[1]))))
dt$date
which(dt$date >= isolate(ymd(input$dates[1])))
dt$date >= isolate(ymd(input$dates[1]))
input$dates[1]
ymd(input$dates[1]))
ymd(input$dates[1])
input <- data.frame(dates = c(Sys.Date() - (5 * 365), Sys.Date() - 1))
stratStartPos <- min(which(dt$date >= format(isolate(input$dates[1]))))
stratEndPos <- max(which(dt$date <= format(isolate(input$dates[2]))))
if (stratStartPos >= stratEndPos) {
updateDateRangeInput(session, inputId = 'dates',
label = h3('Date range'),
start = Sys.Date() - (5 * 365),
end = Sys.Date() - 1,
min = '2001-01-01',
max = Sys.Date() - 1)
stop("EndingDate must be > StartingDate")
}
start.Date <<- format(as.Date(dt$date[stratStartPos]), '%Y-%m-%d')
end.Date   <<- format(as.Date(dt$date[stratEndPos]), '%Y-%m-%d')
# Update the date range picker with the start and end dates, just in
# case the returns file only has a narrower range than the user
x <- dt$date[stratStartPos:stratEndPos]
y <- dt$rtn[stratStartPos:stratEndPos]
# Convert to decimal return values instead of percentage
# values for use with PerformanceAnalytics.
stratReturnsDF <- data.frame(decimalReturn = y/100, row.names = x)
stratReturns.xts <- xts(stratReturnsDF$decimalReturn,
order.by = as.Date(rownames(stratReturnsDF)))
head(stratReturns.xts)
bench.returns <- xts(read.zoo('./refData/gold_returns.xts',
header = TRUE, sep = " "))
if ((max(index(bench.returns)) < end.Date) |
(start.Date < min(index(bench.returns)))) {
# Load some more price data
bench.returns <- updateHistoricalBenchData(
code = 'XAU/USD',
filePrefix = 'gold',
dataSrc = 'oanda',
from.date = start.Date,
to.date = end.Date)
}
}
if ((max(index(bench.returns)) < end.Date) |
(start.Date < min(index(bench.returns)))) {
# Load some more price data
bench.returns <- updateHistoricalBenchData(
code = 'XAU/USD',
filePrefix = 'gold',
dataSrc = 'oanda',
from.date = start.Date,
to.date = end.Date)
}
bench_ret <- bench.returns[paste(start.Date, end.Date, sep = '/')]
combined.returns <- merge.xts(bench_ret, stratReturns.xts)
combined.returns <- combined.returns[complete.cases(combined.returns)]
names(combined.returns) <- c(paste0('Benchmark: ', input$benchmark[1]),
'Strategy')
input$benchmark[1]
input$benchmark[1] <- 'Gold (USD)'
combined.returns <- combined.returns[complete.cases(combined.returns)]
names(combined.returns) <- c(paste0('Benchmark: ', input$benchmark[1]),
'Strategy')
merged.returns <- combined.returns
length(index(merged.returns[merged.returns[,2]>merged.returns[,1]]))
index(merged.returns[merged.returns[,2]>merged.returns[,1]])
length(index(merged.returns))
merged.returns[merged.returns[,2]>merged.returns[,1]]
runApp()
runApp()
runApp()
runApp()
runApp()
library(slidify)
setwd("C:/Users/tplj/Desktop/Pete/Trading Research/GLMNet/DProdProj_Deck")
slidify('index.Rmd')
browseURL('index.html')
slidify('index.Rmd')
publish_github('https://github.com/petemere/tradingSummarySlidify.git', username = 'petermere')
publish(user = 'petermere', repo = 'tradingSummarySlidify')
